import { protectRoute } from "@vaadin/hilla-react-auth";
import { createElement } from "react";
import {
  createBrowserRouter
} from "react-router-dom";
import { convertComponentNameToTitle } from "../shared/convertComponentNameToTitle.js";
import { transformTree } from "../shared/transformTree.js";
function isReactRouteModule(module) {
  return module ? "default" in module && typeof module.default === "function" : true;
}
function createRouteEntry(route) {
  return [`${route.path ?? ""}-${route.children ? "n" : "i"}`, route];
}
class RouterConfigurationBuilder {
  #modifiers = [];
  /**
   * Adds the given routes to the current list of routes. All the routes are
   * deeply merged to preserve the path uniqueness.
   *
   * @param routes - A list of routes to add to the current list.
   */
  withReactRoutes(routes) {
    return this.update(routes);
  }
  /**
   * Adds the given file routes to the current list of routes. All the routes
   * are transformed to React RouterObjects and deeply merged to preserve the
   * path uniqueness.
   *
   * @param routes - A list of routes to add to the current list.
   */
  withFileRoutes(routes) {
    return this.update(routes, (original, added, children) => {
      if (added) {
        const { module, path } = added;
        if (!isReactRouteModule(module)) {
          throw new Error(`The module for the "${path}" section doesn't have the React component exported by default`);
        }
        const element = module?.default ? createElement(module.default) : void 0;
        const handle = {
          ...module?.config,
          title: module?.config?.title ?? convertComponentNameToTitle(module?.default)
        };
        if (path === "" && !children) {
          return {
            ...original,
            element,
            handle,
            index: true
          };
        }
        return {
          ...original,
          path: module?.config?.route ?? path,
          element,
          children,
          handle
        };
      }
      return original;
    });
  }
  /**
   * Adds the given server route element to each branch of the current list of
   * routes.
   *
   * @param component - The React component to add to each branch of the
   * current list of routes.
   * @param config - An optional configuration that will be applied to
   * each fallback component.
   */
  withFallback(component, config) {
    const fallbackRoutes = [
      { path: "*", element: createElement(component), handle: config },
      { index: true, element: createElement(component), handle: config }
    ];
    this.update(fallbackRoutes, (original, added, children) => {
      if (original) {
        if (!children) {
          return original;
        }
        const _fallback = [...fallbackRoutes];
        if (children.some(({ path }) => path === "*")) {
          _fallback.shift();
        }
        if (children.some(({ index: i, path }) => i ?? path?.includes("?"))) {
          _fallback.pop();
        }
        return {
          ...original,
          children: [...children, ..._fallback]
        };
      }
      return added;
    });
    return this;
  }
  /**
   * Protects all the routes that require authentication. For more details see
   * {@link @vaadin/hilla-react-auth#protectRoutes} function.
   *
   * @param redirectPath - the path to redirect to if the route is protected
   * and the user is not authenticated.
   */
  protect(redirectPath) {
    this.update(void 0, (route, _, children) => {
      const finalRoute = protectRoute(route, redirectPath);
      finalRoute.children = children;
      return finalRoute;
    });
    return this;
  }
  update(routes, callback = (original, overriding, children) => ({
    ...original,
    ...overriding,
    children
  })) {
    this.#modifiers.push(
      (existingRoutes) => transformTree(
        [existingRoutes, routes],
        ([original, added], next) => {
          if (original && added) {
            const originalMap = new Map(original.map((route) => createRouteEntry(route)));
            const addedMap = new Map(added.map((route) => createRouteEntry(route)));
            const paths = /* @__PURE__ */ new Set([...originalMap.keys(), ...addedMap.keys()]);
            for (const path of paths) {
              const originalRoute = originalMap.get(path);
              const addedRoute = addedMap.get(path);
              let route;
              if (originalRoute && addedRoute) {
                route = callback(originalRoute, addedRoute, next(originalRoute.children, addedRoute.children));
              } else if (originalRoute) {
                route = callback(originalRoute, void 0, next(originalRoute.children, void 0));
              } else {
                route = callback(void 0, addedRoute, next(void 0, addedRoute.children));
              }
              if (route) {
                originalMap.set(path, route);
              }
            }
            return [...originalMap.values()];
          } else if (original) {
            return original.map((route) => callback(route, void 0, next(route.children, void 0))).filter(Boolean);
          } else if (added) {
            return added.map((route) => callback(void 0, route, next(void 0, route.children))).filter(Boolean);
          }
          return void 0;
        }
      )
    );
    return this;
  }
  /**
   * Builds the router with the current list of routes.
   */
  build(options) {
    const routes = this.#modifiers.reduce((acc, mod) => mod(acc) ?? acc, void 0) ?? [];
    return {
      routes,
      router: createBrowserRouter([...routes], { basename: new URL(document.baseURI).pathname, ...options })
    };
  }
}
export {
  RouterConfigurationBuilder
};
//# sourceMappingURL=RouterConfigurationBuilder.js.map
