{
  "version": 3,
  "sources": ["../src/vite-plugin/generateRuntimeFiles.ts"],
  "sourcesContent": ["import { existsSync } from 'node:fs';\nimport { mkdir, readFile, writeFile } from 'node:fs/promises';\nimport type { Logger } from 'vite';\nimport collectRoutesFromFS from './collectRoutesFromFS.js';\nimport createRoutesFromMeta from './createRoutesFromMeta.js';\nimport createViewConfigJson from './createViewConfigJson.js';\n\n/**\n * The URLs of the files to generate.\n */\nexport type RuntimeFileUrls = Readonly<{\n  /**\n   * The URL of the JSON file with the leaf routes and their metadata. This file\n   * will be processed by the server to provide the final route configuration.\n   */\n  json: URL;\n  /**\n   * The URL of the module with the routes tree in a framework-agnostic format.\n   */\n  code: URL;\n}>;\n\n/**\n * Generates a file conditionally. If the file already exists and its content is the same as the\n * given data, the file will not be overwritten. It is useful to avoid unnecessary server\n * reboot during development.\n *\n * @param url - The URL of the file to generate.\n * @param data - The data to write to the file.\n */\nasync function generateRuntimeFile(url: URL, data: string): Promise<void> {\n  await mkdir(new URL('./', url), { recursive: true });\n  let contents: string | undefined;\n  try {\n    contents = await readFile(url, 'utf-8');\n  } catch (e: unknown) {\n    if (!(e != null && typeof e === 'object' && 'code' in e && e.code === 'ENOENT')) {\n      throw e;\n    }\n  }\n  if (contents !== data) {\n    await writeFile(url, data, 'utf-8');\n  }\n}\n\n/**\n * Collects all file-based routes from the given directory, and based on them generates two files\n * described by {@link RuntimeFileUrls} type.\n * @param viewsDir - The directory that contains file-based routes (views).\n * @param urls - The URLs of the files to generate.\n * @param extensions - The list of extensions that will be collected as routes.\n * @param logger - The Vite logger instance.\n * @param debug - true to debug\n */\nexport async function generateRuntimeFiles(\n  viewsDir: URL,\n  urls: RuntimeFileUrls,\n  extensions: readonly string[],\n  logger: Logger,\n  debug: boolean,\n): Promise<void> {\n  const routeMeta = existsSync(viewsDir) ? await collectRoutesFromFS(viewsDir, { extensions, logger }) : [];\n  if (debug) {\n    logger.info('Collected file-based routes');\n  }\n  const runtimeRoutesCode = createRoutesFromMeta(routeMeta, urls);\n  const viewConfigJson = await createViewConfigJson(routeMeta);\n\n  await Promise.all([\n    generateRuntimeFile(urls.json, viewConfigJson).then(() => {\n      if (debug) {\n        logger.info(`Frontend route list is generated: ${String(urls.json)}`);\n      }\n    }),\n    generateRuntimeFile(urls.code, runtimeRoutesCode).then(() => {\n      if (debug) {\n        logger.info(`File Route module is generated: ${String(urls.code)}`);\n      }\n    }),\n  ]);\n}\n"],
  "mappings": "AAAA,SAAS,kBAAkB;AAC3B,SAAS,OAAO,UAAU,iBAAiB;AAE3C,OAAO,yBAAyB;AAChC,OAAO,0BAA0B;AACjC,OAAO,0BAA0B;AAyBjC,eAAe,oBAAoB,KAAU,MAA6B;AACxE,QAAM,MAAM,IAAI,IAAI,MAAM,GAAG,GAAG,EAAE,WAAW,KAAK,CAAC;AACnD,MAAI;AACJ,MAAI;AACF,eAAW,MAAM,SAAS,KAAK,OAAO;AAAA,EACxC,SAAS,GAAY;AACnB,QAAI,EAAE,KAAK,QAAQ,OAAO,MAAM,YAAY,UAAU,KAAK,EAAE,SAAS,WAAW;AAC/E,YAAM;AAAA,IACR;AAAA,EACF;AACA,MAAI,aAAa,MAAM;AACrB,UAAM,UAAU,KAAK,MAAM,OAAO;AAAA,EACpC;AACF;AAWA,eAAsB,qBACpB,UACA,MACA,YACA,QACA,OACe;AACf,QAAM,YAAY,WAAW,QAAQ,IAAI,MAAM,oBAAoB,UAAU,EAAE,YAAY,OAAO,CAAC,IAAI,CAAC;AACxG,MAAI,OAAO;AACT,WAAO,KAAK,6BAA6B;AAAA,EAC3C;AACA,QAAM,oBAAoB,qBAAqB,WAAW,IAAI;AAC9D,QAAM,iBAAiB,MAAM,qBAAqB,SAAS;AAE3D,QAAM,QAAQ,IAAI;AAAA,IAChB,oBAAoB,KAAK,MAAM,cAAc,EAAE,KAAK,MAAM;AACxD,UAAI,OAAO;AACT,eAAO,KAAK,qCAAqC,OAAO,KAAK,IAAI,CAAC,EAAE;AAAA,MACtE;AAAA,IACF,CAAC;AAAA,IACD,oBAAoB,KAAK,MAAM,iBAAiB,EAAE,KAAK,MAAM;AAC3D,UAAI,OAAO;AACT,eAAO,KAAK,mCAAmC,OAAO,KAAK,IAAI,CAAC,EAAE;AAAA,MACpE;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACH;",
  "names": []
}
