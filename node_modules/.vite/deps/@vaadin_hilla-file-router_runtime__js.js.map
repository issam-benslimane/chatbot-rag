{
  "version": 3,
  "sources": ["../../@vaadin/hilla-file-router/src/runtime/createRoute.ts", "../../@vaadin/hilla-react-auth/src/ProtectedRoute.tsx", "../../@vaadin/hilla-react-auth/src/useAuth.tsx", "../../../scripts/register.js", "../../@vaadin/hilla-react-auth/src/index.ts", "../../@vaadin/hilla-file-router/src/runtime/RouterConfigurationBuilder.ts", "../../@vaadin/hilla-file-router/src/shared/convertComponentNameToTitle.ts", "../../@vaadin/hilla-file-router/src/shared/transformTree.ts", "../../@vaadin/hilla-file-router/src/runtime/useViewConfig.ts", "../../@vaadin/hilla-file-router/src/shared/routeParamType.ts", "../../../scripts/register.js", "../../@vaadin/hilla-file-router/src/runtime/createMenuItems.ts"],
  "sourcesContent": ["import type { AgnosticRoute, Module } from '../types.js';\n\n/**\n * Create a single framework-agnostic route object. Later, it can be transformed into a framework-specific route object,\n * e.g., the one used by React Router.\n *\n * @param path - A route path segment.\n * @param children - An array of child routes.\n *\n * @returns A framework-agnostic route object.\n */\nexport function createRoute(path: string, children?: readonly AgnosticRoute[]): AgnosticRoute;\nexport function createRoute(path: string, module: Module, children?: readonly AgnosticRoute[]): AgnosticRoute;\nexport function createRoute(\n  path: string,\n  moduleOrChildren?: Module | readonly AgnosticRoute[],\n  children?: readonly AgnosticRoute[],\n): AgnosticRoute {\n  let module: Module | undefined;\n  if (Array.isArray(moduleOrChildren)) {\n    // eslint-disable-next-line no-param-reassign\n    children = moduleOrChildren;\n  } else {\n    module = moduleOrChildren as Module | undefined;\n  }\n\n  return {\n    path,\n    module,\n    children,\n  };\n}\n", "import { useContext, type JSX } from 'react';\nimport type { RouteObject } from 'react-router-dom';\nimport { type IndexRouteObject, Navigate, type NonIndexRouteObject, useLocation } from 'react-router-dom';\nimport { type AccessProps, AuthContext } from './useAuth.js';\n\ntype CustomMetadata = Record<string, any>;\n\ntype HandleWithAuth = Readonly<{ handle?: AccessProps & CustomMetadata }>;\n\ntype Override<T, E> = E & Omit<T, keyof E>;\n\ntype IndexRouteObjectWithAuth = Override<IndexRouteObject, HandleWithAuth>;\ntype NonIndexRouteObjectWithAuth = Override<\n  Override<NonIndexRouteObject, HandleWithAuth>,\n  {\n    children?: RouteObjectWithAuth[];\n  }\n>;\nexport type RouteObjectWithAuth = IndexRouteObjectWithAuth | NonIndexRouteObjectWithAuth;\n\ninterface ProtectedRouteProps {\n  redirectPath: string;\n  access: AccessProps;\n  element: JSX.Element;\n}\n\nfunction ProtectedRoute({ redirectPath, access, element }: ProtectedRouteProps): JSX.Element | null {\n  const {\n    state: { initializing, loading, user },\n    hasAccess,\n  } = useContext(AuthContext);\n\n  const location = useLocation();\n\n  if (initializing || loading) {\n    return <div></div>;\n  }\n\n  if (!hasAccess(access)) {\n    return <Navigate to={redirectPath} state={{ from: location }} replace />;\n  }\n\n  return element;\n}\nProtectedRoute.type = 'ProtectedRoute'; // This is for copilot to recognize this\n\nfunction* traverse<T extends RouteObject>(routes: T[]): Generator<T, undefined, undefined> {\n  for (const route of routes) {\n    yield route;\n    if (route.children) {\n      yield* traverse(route.children as T[]);\n    }\n  }\n}\n\n/**\n * Adds protection to a single route that requires authentication.\n * These route should contain the {@link AccessProps.loginRequired} and/or\n * {@link AccessProps.rolesAllowed} property to get the protection. Route\n * without that property won't be protected.\n *\n * @param route - the route to protect\n * @param redirectPath - the path to redirect to if the route is protected\n * and the user is not authenticated.\n * @returns the route extended with protection if needed\n */\nexport function protectRoute(route: RouteObjectWithAuth, redirectPath: string = '/login'): RouteObjectWithAuth {\n  const { handle } = route;\n  const requiresAuth = handle?.loginRequired ?? handle?.requiresLogin ?? handle?.rolesAllowed?.length;\n\n  if (requiresAuth) {\n    route.element = (\n      <ProtectedRoute\n        redirectPath={redirectPath}\n        access={handle as AccessProps}\n        element={route.element as JSX.Element}\n      />\n    );\n  }\n\n  return route;\n}\n\n/**\n * Protects a route tree with {@link protectRoute} function.\n *\n * @param routes - the roots of the route tree that requires protection.\n * @param redirectPath - the path to redirect to if the route is\n * protected and the user is not authenticated.\n * @returns the protected route tree\n */\nexport function protectRoutes(routes: RouteObjectWithAuth[], redirectPath: string = '/login'): RouteObjectWithAuth[] {\n  for (const route of traverse(routes)) {\n    protectRoute(route, redirectPath);\n  }\n\n  return routes;\n}\n", "import {\n  login as _login,\n  type LoginOptions,\n  type LoginResult,\n  logout as _logout,\n  type LogoutOptions,\n  UnauthorizedResponseError,\n} from '@vaadin/hilla-frontend';\nimport { createContext, type Dispatch, useContext, useEffect, useReducer } from 'react';\n\ntype LoginFunction = (username: string, password: string) => Promise<LoginResult>;\ntype LogoutFunction = () => Promise<void>;\n\nconst LOGIN_FETCH = 'LOGIN_FETCH';\nconst LOGIN_SUCCESS = 'LOGIN_SUCCESS';\nconst LOGIN_FAILURE = 'LOGIN_FAILURE';\nconst LOGOUT = 'LOGOUT';\n\n/**\n * The type of the function that is used to get the authenticated user.\n */\nexport type GetUserFn<TUser> = () => Promise<TUser | undefined>;\n\ntype AuthState<TUser> = Readonly<{\n  initializing: boolean;\n  loading: boolean;\n  user?: TUser;\n  error?: string;\n  getAuthenticatedUser?: GetUserFn<TUser>;\n}>;\n\ntype LoginFetchAction = Readonly<{\n  type: typeof LOGIN_FETCH;\n}>;\n\ntype LoginSuccessAction = Readonly<{\n  user: unknown;\n  type: typeof LOGIN_SUCCESS;\n}>;\n\ntype LoginFailureAction = Readonly<{\n  error: string;\n  type: typeof LOGIN_FAILURE;\n}>;\n\ntype LoginActions = LoginFailureAction | LoginFetchAction | LoginSuccessAction;\n\ntype LogoutAction = Readonly<{\n  type: typeof LOGOUT;\n}>;\n\nfunction createAuthenticateThunk<TUser>(dispatch: Dispatch<LoginActions>, getAuthenticatedUser: GetUserFn<TUser>) {\n  async function authenticate() {\n    dispatch({ type: LOGIN_FETCH });\n\n    // Get user info from endpoint\n    const user = await getAuthenticatedUser().catch((error: unknown) => {\n      if (error instanceof UnauthorizedResponseError) {\n        // 401 response: the user is not authenticated\n        return undefined;\n      }\n\n      throw error;\n    });\n\n    if (user) {\n      dispatch({\n        user,\n        type: LOGIN_SUCCESS,\n      });\n    } else {\n      dispatch({\n        error: 'Not authenticated',\n        type: LOGIN_FAILURE,\n      });\n    }\n  }\n\n  return authenticate;\n}\n\nfunction createUnauthenticateThunk(dispatch: Dispatch<LogoutAction>) {\n  return () => {\n    dispatch({ type: LOGOUT });\n  };\n}\n\nconst initialState: AuthState<unknown> = {\n  initializing: true,\n  loading: false,\n};\n\nfunction reducer(state: AuthState<unknown>, action: LoginActions | LogoutAction) {\n  switch (action.type) {\n    case LOGIN_FETCH:\n      return {\n        initializing: false,\n        loading: true,\n      };\n    case LOGIN_SUCCESS:\n      return {\n        initializing: false,\n        loading: false,\n        user: action.user,\n      };\n    case LOGIN_FAILURE:\n      return {\n        initializing: false,\n        loading: false,\n        error: action.error,\n      };\n    case LOGOUT:\n      return { initializing: false, loading: false };\n    default:\n      return state;\n  }\n}\n\n/**\n * The properties that can be used to control access to a route.\n * They can be added to the route type handler as properties.\n */\nexport type AccessProps = Readonly<{\n  /**\n   * If true, the user must be logged in to access the route.\n   */\n  loginRequired?: boolean;\n  /**\n   * If true, the user must be logged in to access the route.\n   *\n   * @deprecated Use `loginRequired` instead.\n   */\n  requiresLogin?: boolean;\n  /**\n   * The list of roles that are allowed to access the route.\n   */\n  rolesAllowed?: readonly [string, ...string[]];\n}>;\n\n/**\n * The type of the authentication hook.\n */\nexport type Authentication<TUser> = Readonly<{\n  state: AuthState<TUser>;\n  login: LoginFunction;\n  logout: LogoutFunction;\n  hasAccess(accessProps: AccessProps): boolean;\n}>;\n\n/**\n * The hook that can be used to get the authentication state.\n * It returns the state of the authentication.\n */\nexport const AuthContext = createContext<Authentication<unknown>>({\n  state: initialState,\n  login() {\n    throw new Error('AuthContext not initialized');\n  },\n  logout() {\n    throw new Error('AuthContext not initialized');\n  },\n  hasAccess(): boolean {\n    throw new Error('AuthContext not initialized');\n  },\n});\n\ninterface AuthConfig<TUser> {\n  getRoles?(user: TUser): readonly string[];\n}\n\ninterface AuthProviderProps<TUser> extends React.PropsWithChildren {\n  getAuthenticatedUser: GetUserFn<TUser>;\n  config?: AuthConfig<TUser>;\n}\n\ninterface UserWithRoles {\n  roles?: any;\n}\n\nconst getDefaultRoles = (user: unknown) => {\n  const userWithRoles = user as UserWithRoles;\n  return Array.isArray(userWithRoles.roles) ? userWithRoles.roles : [];\n};\n\nfunction AuthProvider<TUser>({ children, getAuthenticatedUser, config }: AuthProviderProps<TUser>) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const authenticate = createAuthenticateThunk(dispatch, getAuthenticatedUser);\n  const unauthenticate = createUnauthenticateThunk(dispatch);\n\n  async function login(username: string, password: string, options?: LoginOptions): Promise<LoginResult> {\n    const result = await _login(username, password, options);\n\n    if (!result.error) {\n      await authenticate();\n    }\n\n    return result;\n  }\n\n  async function logout(options?: LogoutOptions): Promise<void> {\n    await _logout(options);\n    unauthenticate();\n  }\n\n  function hasAccess({ loginRequired, requiresLogin, rolesAllowed }: AccessProps): boolean {\n    const requiresAuth = loginRequired ?? requiresLogin ?? rolesAllowed;\n    if (!requiresAuth) {\n      return true;\n    }\n\n    if (!state.user) {\n      return false;\n    }\n\n    if (rolesAllowed) {\n      const userRoles = config?.getRoles ? config.getRoles(state.user as TUser) : getDefaultRoles(state.user);\n      return rolesAllowed.some((allowedRole) => userRoles.includes(allowedRole));\n    }\n\n    return true;\n  }\n\n  useEffect(() => {\n    authenticate().catch(() => {\n      // Do nothing\n    });\n  }, []);\n\n  const auth = {\n    state,\n    login,\n    logout,\n    hasAccess,\n  };\n\n  return <AuthContext.Provider value={auth}>{children}</AuthContext.Provider>;\n}\n\nexport type AuthHook<TUser> = () => Authentication<TUser>;\n\n/**\n * The hook that can be used to authenticate the user.\n * It returns the state of the authentication and the functions\n * to authenticate and unauthenticate the user.\n */\nfunction useAuth<TUser>(): Authentication<TUser> {\n  return useContext(AuthContext) as Authentication<TUser>;\n}\n\ninterface AuthModule<TUser> {\n  AuthProvider: React.FC<React.PropsWithChildren>;\n  useAuth: AuthHook<TUser>;\n}\n\nexport function configureAuth<TUser>(\n  getAuthenticatedUser: GetUserFn<TUser>,\n  config?: AuthConfig<TUser>,\n): AuthModule<TUser> {\n  function PreconfiguredAuthProvider({ children }: React.PropsWithChildren) {\n    return (\n      <AuthProvider<TUser> getAuthenticatedUser={getAuthenticatedUser} config={config}>\n        {children}\n      </AuthProvider>\n    );\n  }\n\n  return {\n    AuthProvider: PreconfiguredAuthProvider,\n    useAuth: useAuth as AuthHook<TUser>,\n  };\n}\n", "export function __REGISTER__(feature, vaadinObj = (window.Vaadin ??= {})) {\n  vaadinObj.registrations ??= [];\n  vaadinObj.registrations.push({\n    is: feature ? `${__NAME__}/${feature}` : __NAME__,\n    version: __VERSION__,\n  });\n}\n", "export * from './ProtectedRoute.js';\nexport * from './useAuth.js';\n\n// @ts-expect-error: esbuild injection\n// eslint-disable-next-line @typescript-eslint/no-unsafe-call\n__REGISTER__();\n", "/* eslint-disable @typescript-eslint/consistent-type-assertions */\nimport { protectRoute } from '@vaadin/hilla-react-auth';\nimport { type ComponentType, createElement } from 'react';\nimport {\n  createBrowserRouter,\n  type IndexRouteObject,\n  type NonIndexRouteObject,\n  type RouteObject,\n} from 'react-router-dom';\nimport { convertComponentNameToTitle } from '../shared/convertComponentNameToTitle.js';\nimport { transformTree } from '../shared/transformTree.js';\nimport type {\n  AgnosticRoute,\n  Module,\n  RouteModule,\n  RouterBuildOptions,\n  RouterConfiguration,\n  ViewConfig,\n} from '../types.js';\n\ninterface RouteBase {\n  path?: string;\n  children?: readonly this[];\n}\n\ntype RoutesModifier = (routes: readonly RouteObject[] | undefined) => readonly RouteObject[] | undefined;\n\nfunction isReactRouteModule(module?: Module): module is RouteModule<ComponentType> | undefined {\n  return module ? 'default' in module && typeof module.default === 'function' : true;\n}\n\ntype RouteTransformer<T> = (\n  original: RouteObject | undefined,\n  overriding: T | undefined,\n  children?: readonly RouteObject[],\n) => RouteObject | undefined;\n\nfunction createRouteEntry<T extends RouteBase>(route: T): readonly [key: string, value: T] {\n  return [`${route.path ?? ''}-${route.children ? 'n' : 'i'}`, route];\n}\n\n/**\n * A builder for creating a Vaadin-specific router for React with\n * authentication and server routes support.\n */\nexport class RouterConfigurationBuilder {\n  readonly #modifiers: RoutesModifier[] = [];\n\n  /**\n   * Adds the given routes to the current list of routes. All the routes are\n   * deeply merged to preserve the path uniqueness.\n   *\n   * @param routes - A list of routes to add to the current list.\n   */\n  withReactRoutes(routes: readonly RouteObject[]): this {\n    return this.update(routes);\n  }\n\n  /**\n   * Adds the given file routes to the current list of routes. All the routes\n   * are transformed to React RouterObjects and deeply merged to preserve the\n   * path uniqueness.\n   *\n   * @param routes - A list of routes to add to the current list.\n   */\n  withFileRoutes(routes: readonly AgnosticRoute[]): this {\n    return this.update(routes, (original, added, children) => {\n      if (added) {\n        const { module, path } = added;\n        if (!isReactRouteModule(module)) {\n          throw new Error(`The module for the \"${path}\" section doesn't have the React component exported by default`);\n        }\n\n        const element = module?.default ? createElement(module.default) : undefined;\n        const handle = {\n          ...module?.config,\n          title: module?.config?.title ?? convertComponentNameToTitle(module?.default),\n        };\n\n        if (path === '' && !children) {\n          return {\n            ...original,\n            element,\n            handle,\n            index: true,\n          } as IndexRouteObject;\n        }\n\n        return {\n          ...original,\n          path: module?.config?.route ?? path,\n          element,\n          children,\n          handle,\n        } as NonIndexRouteObject;\n      }\n\n      return original;\n    });\n  }\n\n  /**\n   * Adds the given server route element to each branch of the current list of\n   * routes.\n   *\n   * @param component - The React component to add to each branch of the\n   * current list of routes.\n   * @param config - An optional configuration that will be applied to\n   * each fallback component.\n   */\n  withFallback(component: ComponentType, config?: ViewConfig): this {\n    // Fallback adds two routes, so that the index (empty path) has a fallback too\n    const fallbackRoutes: readonly RouteObject[] = [\n      { path: '*', element: createElement(component), handle: config },\n      { index: true, element: createElement(component), handle: config },\n    ];\n\n    this.update(fallbackRoutes, (original, added, children) => {\n      if (original) {\n        if (!children) {\n          return original;\n        }\n\n        const _fallback = [...fallbackRoutes];\n\n        if (children.some(({ path }) => path === '*')) {\n          _fallback.shift();\n        }\n\n        if (children.some(({ index: i, path }) => i ?? path?.includes('?'))) {\n          _fallback.pop();\n        }\n\n        return {\n          ...original,\n          children: [...children, ..._fallback],\n        } as RouteObject;\n      }\n\n      return added!;\n    });\n\n    return this;\n  }\n\n  /**\n   * Protects all the routes that require authentication. For more details see\n   * {@link @vaadin/hilla-react-auth#protectRoutes} function.\n   *\n   * @param redirectPath - the path to redirect to if the route is protected\n   * and the user is not authenticated.\n   */\n  protect(redirectPath?: string): this {\n    this.update(undefined, (route, _, children) => {\n      const finalRoute = protectRoute(route!, redirectPath);\n      finalRoute.children = children as RouteObject[] | undefined;\n      return finalRoute;\n    });\n\n    return this;\n  }\n\n  update<T extends RouteBase>(routes: undefined, callback: RouteTransformer<undefined>): this;\n  update<T extends RouteBase>(routes: readonly T[], callback?: RouteTransformer<T>): this;\n  update<T extends RouteBase>(\n    routes: readonly T[] | undefined,\n    callback: RouteTransformer<T | undefined> = (original, overriding, children) =>\n      ({\n        ...original,\n        ...overriding,\n        children,\n      }) as RouteObject,\n  ): this {\n    this.#modifiers.push((existingRoutes) =>\n      transformTree<[readonly RouteObject[] | undefined, readonly T[] | undefined], readonly RouteObject[] | undefined>(\n        [existingRoutes, routes],\n        ([original, added], next) => {\n          if (original && added) {\n            const originalMap = new Map(original.map((route) => createRouteEntry(route)));\n            const addedMap = new Map(added.map((route) => createRouteEntry(route)));\n\n            const paths = new Set([...originalMap.keys(), ...addedMap.keys()]);\n\n            for (const path of paths) {\n              const originalRoute = originalMap.get(path);\n              const addedRoute = addedMap.get(path);\n\n              let route: RouteObject | undefined;\n              if (originalRoute && addedRoute) {\n                route = callback(originalRoute, addedRoute, next(originalRoute.children, addedRoute.children));\n              } else if (originalRoute) {\n                route = callback(originalRoute, undefined, next(originalRoute.children, undefined));\n              } else {\n                route = callback(undefined, addedRoute, next(undefined, addedRoute!.children));\n              }\n\n              if (route) {\n                originalMap.set(path, route);\n              }\n            }\n\n            return [...originalMap.values()];\n          } else if (original) {\n            return original\n              .map((route) => callback(route, undefined, next(route.children, undefined)))\n              .filter(Boolean) as readonly RouteObject[];\n          } else if (added) {\n            return added\n              .map((route) => callback(undefined, route, next(undefined, route.children)))\n              .filter(Boolean) as readonly RouteObject[];\n          }\n\n          return undefined;\n        },\n      ),\n    );\n    return this;\n  }\n\n  /**\n   * Builds the router with the current list of routes.\n   */\n  build(options?: RouterBuildOptions): RouterConfiguration {\n    const routes =\n      this.#modifiers.reduce<readonly RouteObject[] | undefined>((acc, mod) => mod(acc) ?? acc, undefined) ?? [];\n\n    return {\n      routes,\n      router: createBrowserRouter([...routes], { basename: new URL(document.baseURI).pathname, ...options }),\n    };\n  }\n}\n", "const viewPattern = /view/giu;\nconst upperCaseSplitPattern = /(?=[A-Z])/gu;\n\n/**\n * Converts the name of the component to a page title.\n *\n * @param component - The component to convert the name from.\n *\n * @returns The page title.\n */\nexport function convertComponentNameToTitle(component: unknown): string {\n  let name: string;\n\n  if (\n    component &&\n    (typeof component === 'object' || typeof component === 'function') &&\n    'name' in component &&\n    typeof component.name === 'string'\n  ) {\n    ({ name } = component);\n  } else {\n    name = String(component);\n  }\n\n  return name.replace(viewPattern, '').split(upperCaseSplitPattern).join(' ');\n}\n", "export function transformTree<T extends readonly unknown[], U>(\n  nodes: T,\n  transformer: (nodes: T, next: (...nodes: T) => U) => U,\n): U {\n  return transformer(nodes, (...n) => transformTree(n, transformer));\n}\n", "import type { UIMatch } from '@remix-run/router';\nimport { useMatches } from 'react-router-dom';\nimport type { ViewConfig } from '../types.js';\n\n/**\n * Hook to return the {@link ViewConfig} for the current route.\n */\nexport function useViewConfig<M extends ViewConfig>(): M | undefined {\n  const matches = useMatches() as ReadonlyArray<UIMatch<unknown, M>>;\n  return matches[matches.length - 1]?.handle;\n}\n", "/**\n * The type of route parameter.\n */\nexport enum RouteParamType {\n  Required = 'req',\n  Optional = 'opt',\n  Wildcard = '*',\n}\n", "export function __REGISTER__(feature, vaadinObj = (window.Vaadin ??= {})) {\n  vaadinObj.registrations ??= [];\n  vaadinObj.registrations.push({\n    is: feature ? `${__NAME__}/${feature}` : __NAME__,\n    version: __VERSION__,\n  });\n}\n", "import type { VaadinWindow } from '../shared/internal.js';\nimport { RouteParamType } from '../shared/routeParamType.js';\nimport type { MenuItem, ViewConfig } from '../types.js';\n\n/**\n * Creates menu items from the views provided by the server. The views are sorted according to the\n * {@link ViewConfig.menu.order}, filtered out if they are explicitly excluded via {@link ViewConfig.menu.exclude}.\n * Note that views with no order are put below views with an order. Ties are resolved based on the path string\n * comparison.\n *\n * @param vaadinObject - The Vaadin object containing the server views.\n * @returns A list of menu items.\n */\nexport function createMenuItems(vaadinObject = (window as VaadinWindow).Vaadin): readonly MenuItem[] {\n  // @ts-expect-error: esbuild injection\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n  __REGISTER__('createMenuItems', vaadinObject);\n  const collator = new Intl.Collator('en-US');\n  return vaadinObject?.views\n    ? Object.entries(vaadinObject.views)\n        // Filter out the views that are explicitly excluded from the menu.\n        .filter(\n          ([_key, value]) =>\n            !value.menu?.exclude &&\n            !(value.params && Object.values(value.params).some((p) => p === RouteParamType.Required)),\n        )\n        // Map the views to menu items.\n        .map(([path, config]) => {\n          const _path = config.params\n            ? Object.keys(config.params).reduce((acc, key) => acc.replaceAll(key, ''), path)\n            : path;\n\n          return {\n            to: _path,\n            icon: config.menu?.icon,\n            title: config.menu?.title ?? config.title,\n            order: config.menu?.order,\n          };\n        })\n        // Sort views according to the order specified in the view configuration.\n        .sort((menuA, menuB) => {\n          const ordersDiff = (menuA.order ?? Number.MAX_VALUE) - (menuB.order ?? Number.MAX_VALUE);\n          return ordersDiff !== 0 ? ordersDiff : collator.compare(menuA.to, menuB.to);\n        })\n    : [];\n}\n"],
  "mappings": "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",
  "names": ["import_jsx_runtime", "import_react", "import_react", "RouteParamType", "__REGISTER__"]
}
