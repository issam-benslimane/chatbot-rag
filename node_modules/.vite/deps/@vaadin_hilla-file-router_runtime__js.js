import "./chunk-MIPX2R4T.js";
import {
  Navigate,
  createBrowserRouter,
  useLocation,
  useMatches
} from "./chunk-65HFPQFN.js";
import "./chunk-E4UNORPT.js";
import {
  require_jsx_runtime
} from "./chunk-SKCOSPGW.js";
import {
  require_react
} from "./chunk-IF5A3MEL.js";
import "./chunk-5KP7IUG2.js";
import "./chunk-BO44JZTP.js";
import {
  __privateAdd,
  __privateGet,
  __toESM
} from "./chunk-547O27LD.js";

// node_modules/@vaadin/hilla-file-router/runtime/createRoute.js
function createRoute(path, moduleOrChildren, children) {
  let module;
  if (Array.isArray(moduleOrChildren)) {
    children = moduleOrChildren;
  } else {
    module = moduleOrChildren;
  }
  return {
    path,
    module,
    children
  };
}

// node_modules/@vaadin/hilla-react-auth/ProtectedRoute.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-react-auth/useAuth.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);
var initialState = {
  initializing: true,
  loading: false
};
var AuthContext = (0, import_react.createContext)({
  state: initialState,
  login() {
    throw new Error("AuthContext not initialized");
  },
  logout() {
    throw new Error("AuthContext not initialized");
  },
  hasAccess() {
    throw new Error("AuthContext not initialized");
  }
});

// node_modules/@vaadin/hilla-react-auth/ProtectedRoute.js
function ProtectedRoute({ redirectPath, access, element }) {
  const {
    state: { initializing, loading, user },
    hasAccess
  } = (0, import_react2.useContext)(AuthContext);
  const location = useLocation();
  if (initializing || loading) {
    return (0, import_jsx_runtime2.jsx)("div", {});
  }
  if (!hasAccess(access)) {
    return (0, import_jsx_runtime2.jsx)(Navigate, { to: redirectPath, state: { from: location }, replace: true });
  }
  return element;
}
ProtectedRoute.type = "ProtectedRoute";
function protectRoute(route, redirectPath = "/login") {
  var _a;
  const { handle } = route;
  const requiresAuth = (handle == null ? void 0 : handle.loginRequired) ?? (handle == null ? void 0 : handle.requiresLogin) ?? ((_a = handle == null ? void 0 : handle.rolesAllowed) == null ? void 0 : _a.length);
  if (requiresAuth) {
    route.element = (0, import_jsx_runtime2.jsx)(
      ProtectedRoute,
      {
        redirectPath,
        access: handle,
        element: route.element
      }
    );
  }
  return route;
}

// node_modules/@vaadin/hilla-react-auth/index.js
function __REGISTER__(feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `${"@vaadin/hilla-react-auth"}/${feature}` : "@vaadin/hilla-react-auth",
    version: "24.4.3"
  });
}
__REGISTER__();

// node_modules/@vaadin/hilla-file-router/runtime/RouterConfigurationBuilder.js
var import_react3 = __toESM(require_react(), 1);

// node_modules/@vaadin/hilla-file-router/shared/convertComponentNameToTitle.js
var viewPattern = /view/giu;
var upperCaseSplitPattern = /(?=[A-Z])/gu;
function convertComponentNameToTitle(component) {
  let name;
  if (component && (typeof component === "object" || typeof component === "function") && "name" in component && typeof component.name === "string") {
    ({ name } = component);
  } else {
    name = String(component);
  }
  return name.replace(viewPattern, "").split(upperCaseSplitPattern).join(" ");
}

// node_modules/@vaadin/hilla-file-router/shared/transformTree.js
function transformTree(nodes, transformer) {
  return transformer(nodes, (...n) => transformTree(n, transformer));
}

// node_modules/@vaadin/hilla-file-router/runtime/RouterConfigurationBuilder.js
function isReactRouteModule(module) {
  return module ? "default" in module && typeof module.default === "function" : true;
}
function createRouteEntry(route) {
  return [`${route.path ?? ""}-${route.children ? "n" : "i"}`, route];
}
var _modifiers;
var RouterConfigurationBuilder = class {
  constructor() {
    __privateAdd(this, _modifiers, []);
  }
  /**
   * Adds the given routes to the current list of routes. All the routes are
   * deeply merged to preserve the path uniqueness.
   *
   * @param routes - A list of routes to add to the current list.
   */
  withReactRoutes(routes) {
    return this.update(routes);
  }
  /**
   * Adds the given file routes to the current list of routes. All the routes
   * are transformed to React RouterObjects and deeply merged to preserve the
   * path uniqueness.
   *
   * @param routes - A list of routes to add to the current list.
   */
  withFileRoutes(routes) {
    return this.update(routes, (original, added, children) => {
      var _a, _b;
      if (added) {
        const { module, path } = added;
        if (!isReactRouteModule(module)) {
          throw new Error(`The module for the "${path}" section doesn't have the React component exported by default`);
        }
        const element = (module == null ? void 0 : module.default) ? (0, import_react3.createElement)(module.default) : void 0;
        const handle = {
          ...module == null ? void 0 : module.config,
          title: ((_a = module == null ? void 0 : module.config) == null ? void 0 : _a.title) ?? convertComponentNameToTitle(module == null ? void 0 : module.default)
        };
        if (path === "" && !children) {
          return {
            ...original,
            element,
            handle,
            index: true
          };
        }
        return {
          ...original,
          path: ((_b = module == null ? void 0 : module.config) == null ? void 0 : _b.route) ?? path,
          element,
          children,
          handle
        };
      }
      return original;
    });
  }
  /**
   * Adds the given server route element to each branch of the current list of
   * routes.
   *
   * @param component - The React component to add to each branch of the
   * current list of routes.
   * @param config - An optional configuration that will be applied to
   * each fallback component.
   */
  withFallback(component, config) {
    const fallbackRoutes = [
      { path: "*", element: (0, import_react3.createElement)(component), handle: config },
      { index: true, element: (0, import_react3.createElement)(component), handle: config }
    ];
    this.update(fallbackRoutes, (original, added, children) => {
      if (original) {
        if (!children) {
          return original;
        }
        const _fallback = [...fallbackRoutes];
        if (children.some(({ path }) => path === "*")) {
          _fallback.shift();
        }
        if (children.some(({ index: i, path }) => i ?? (path == null ? void 0 : path.includes("?")))) {
          _fallback.pop();
        }
        return {
          ...original,
          children: [...children, ..._fallback]
        };
      }
      return added;
    });
    return this;
  }
  /**
   * Protects all the routes that require authentication. For more details see
   * {@link @vaadin/hilla-react-auth#protectRoutes} function.
   *
   * @param redirectPath - the path to redirect to if the route is protected
   * and the user is not authenticated.
   */
  protect(redirectPath) {
    this.update(void 0, (route, _, children) => {
      const finalRoute = protectRoute(route, redirectPath);
      finalRoute.children = children;
      return finalRoute;
    });
    return this;
  }
  update(routes, callback = (original, overriding, children) => ({
    ...original,
    ...overriding,
    children
  })) {
    __privateGet(this, _modifiers).push(
      (existingRoutes) => transformTree(
        [existingRoutes, routes],
        ([original, added], next) => {
          if (original && added) {
            const originalMap = new Map(original.map((route) => createRouteEntry(route)));
            const addedMap = new Map(added.map((route) => createRouteEntry(route)));
            const paths = /* @__PURE__ */ new Set([...originalMap.keys(), ...addedMap.keys()]);
            for (const path of paths) {
              const originalRoute = originalMap.get(path);
              const addedRoute = addedMap.get(path);
              let route;
              if (originalRoute && addedRoute) {
                route = callback(originalRoute, addedRoute, next(originalRoute.children, addedRoute.children));
              } else if (originalRoute) {
                route = callback(originalRoute, void 0, next(originalRoute.children, void 0));
              } else {
                route = callback(void 0, addedRoute, next(void 0, addedRoute.children));
              }
              if (route) {
                originalMap.set(path, route);
              }
            }
            return [...originalMap.values()];
          } else if (original) {
            return original.map((route) => callback(route, void 0, next(route.children, void 0))).filter(Boolean);
          } else if (added) {
            return added.map((route) => callback(void 0, route, next(void 0, route.children))).filter(Boolean);
          }
          return void 0;
        }
      )
    );
    return this;
  }
  /**
   * Builds the router with the current list of routes.
   */
  build(options) {
    const routes = __privateGet(this, _modifiers).reduce((acc, mod) => mod(acc) ?? acc, void 0) ?? [];
    return {
      routes,
      router: createBrowserRouter([...routes], { basename: new URL(document.baseURI).pathname, ...options })
    };
  }
};
_modifiers = new WeakMap();

// node_modules/@vaadin/hilla-file-router/runtime/useViewConfig.js
function useViewConfig() {
  var _a;
  const matches = useMatches();
  return (_a = matches[matches.length - 1]) == null ? void 0 : _a.handle;
}

// node_modules/@vaadin/hilla-file-router/shared/routeParamType.js
var RouteParamType = ((RouteParamType2) => {
  RouteParamType2["Required"] = "req";
  RouteParamType2["Optional"] = "opt";
  RouteParamType2["Wildcard"] = "*";
  return RouteParamType2;
})(RouteParamType || {});

// node_modules/@vaadin/hilla-file-router/runtime/createMenuItems.js
function __REGISTER__2(feature, vaadinObj = window.Vaadin ?? (window.Vaadin = {})) {
  vaadinObj.registrations ?? (vaadinObj.registrations = []);
  vaadinObj.registrations.push({
    is: feature ? `${"@vaadin/hilla-file-router"}/${feature}` : "@vaadin/hilla-file-router",
    version: "24.4.3"
  });
}
function createMenuItems(vaadinObject = window.Vaadin) {
  __REGISTER__2("createMenuItems", vaadinObject);
  const collator = new Intl.Collator("en-US");
  return (vaadinObject == null ? void 0 : vaadinObject.views) ? Object.entries(vaadinObject.views).filter(
    ([_key, value]) => {
      var _a;
      return !((_a = value.menu) == null ? void 0 : _a.exclude) && !(value.params && Object.values(value.params).some((p) => p === RouteParamType.Required));
    }
  ).map(([path, config]) => {
    var _a, _b, _c;
    const _path = config.params ? Object.keys(config.params).reduce((acc, key) => acc.replaceAll(key, ""), path) : path;
    return {
      to: _path,
      icon: (_a = config.menu) == null ? void 0 : _a.icon,
      title: ((_b = config.menu) == null ? void 0 : _b.title) ?? config.title,
      order: (_c = config.menu) == null ? void 0 : _c.order
    };
  }).sort((menuA, menuB) => {
    const ordersDiff = (menuA.order ?? Number.MAX_VALUE) - (menuB.order ?? Number.MAX_VALUE);
    return ordersDiff !== 0 ? ordersDiff : collator.compare(menuA.to, menuB.to);
  }) : [];
}
export {
  RouterConfigurationBuilder,
  createMenuItems,
  createRoute,
  useViewConfig
};
//# sourceMappingURL=@vaadin_hilla-file-router_runtime__js.js.map
